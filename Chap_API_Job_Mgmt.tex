%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter: Job Allocation Management
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Job Management and Reporting}
\label{chap:api_job_mgmt}

The job management \acp{API} provide an application with the ability to orchestrate its operation in partnership with the \ac{SMS}.
Members of this category include the \refapi{PMIx_Allocation_request}, \refapi{PMIx_Job_control}, and \refapi{PMIx_Process_monitor} \acp{API}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Allocation Requests}
\label{chap:api_job_mgmt:alloc}

This section defines functionality to request new allocations from the \ac{RM}, and request modifications to existing allocations.
These are primarily used in the following scenarios:
\begin{itemize}
\item \textit{Evolving} applications that dynamically request and return resources as they execute.
\item \textit{Malleable} environments where the scheduler redirects resources away from executing applications for higher priority jobs or load balancing.
\item \textit{Resilient} applications that need to request replacement resources in the face of failures.
\item \textit{Rigid} jobs where the user has requested a static allocation of resources for a fixed period of time, but realizes that they underestimated their required time while executing.
\end{itemize}
\ac{PMIx} attempts to address this range of use-cases with a flexible \ac{API}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Allocation_request}}
\declareapi{PMIx_Allocation_request}

%%%%
\summary

Request an allocation operation from the host resource manager.

%%%%
\format

\copySignature{PMIx_Allocation_request}{3.0}{
pmix_status_t \\
PMIx_Allocation_request(pmix_alloc_directive_t directive, \\
\hspace*{24\sigspace}pmix_info_t info[], size_t ninfo, \\
\hspace*{24\sigspace}pmix_info_t *results[], size_t *nresults);
}

\begin{arglist}
\argin{directive}{Allocation directive (\refstruct{pmix_alloc_directive_t})}
\argin{info}{Array of \refstruct{pmix_info_t} structures (array of handles)}
\argin{ninfo}{Number of elements in the \refarg{info} array (integer)}
\arginout{results}{Address where a pointer to an array of \refstruct{pmix_info_t} containing the results of the request can be returned (memory reference)}
\arginout{nresults}{Address where the number of elements in \refarg{results} can be returned (handle)}
\end{arglist}

\returnsimple

\reqattrstart
\ac{PMIx} libraries are not required to directly support any attributes for this function. However, any provided attributes must be passed to the host \ac{SMS} daemon for processing, and the \ac{PMIx} library is \textit{required} to add the \refAttributeItem{PMIX_USERID} and the \refAttributeItem{PMIX_GRPID} attributes of the client process making the request.

Host environments that implement support for this operation are required to support the following attributes:

\pasteAttributeItem{PMIX_ALLOC_REQ_ID}
\pasteAttributeItem{PMIX_ALLOC_NUM_NODES}
\pasteAttributeItem{PMIX_ALLOC_NUM_CPUS}
\pasteAttributeItem{PMIX_ALLOC_TIME}

\reqattrend

\optattrstart
The following attributes are optional for host environments that support this operation:

\pasteAttributeItem{PMIX_ALLOC_NODE_LIST}
\pasteAttributeItem{PMIX_ALLOC_NUM_CPU_LIST}
\pasteAttributeItem{PMIX_ALLOC_CPU_LIST}
\pasteAttributeItem{PMIX_ALLOC_MEM_SIZE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_ID}
\pasteAttributeItem{PMIX_ALLOC_BANDWIDTH}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_QOS}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_TYPE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_PLANE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_ENDPTS}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_ENDPTS_NODE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_SEC_KEY}

\optattrend

%%%%
\descr

Request an allocation operation from the host resource manager.
Several broad categories are envisioned, including the ability to:

\begin{compactitem}
%
\item Request allocation of additional resources, including memory, bandwidth, and compute.
This should be accomplished in a non-blocking manner so that the application can continue to progress while waiting for resources to become available.
Note that the new allocation will be disjoint from (i.e., not affiliated with) the allocation of the requestor - thus the termination of one allocation will not impact the other.
%
\item Extend the reservation on currently allocated resources, subject to scheduling availability and priorities.
This includes extending the time limit on current resources, and/or requesting additional resources be allocated to the requesting job.
Any additional allocated resources will be considered as part of the current allocation, and thus will be released at the same time.
%
\item Return no-longer-required resources to the scheduler.
This includes the ``loan'' of resources back to the scheduler with a promise to return them upon subsequent request.
\end{compactitem}

If successful, the returned results for a request for additional resources must include the host resource manager's identifier (\refattr{PMIX_ALLOC_ID}) that the requester can use to specify the resources in, for example, a call to \refapi{PMIx_Spawn}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Allocation_request_nb}}
\declareapi{PMIx_Allocation_request_nb}

%%%%
\summary

Request an allocation operation from the host resource manager.

%%%%
\format

\copySignature{PMIx_Allocation_request_nb}{2.0}{
pmix_status_t \\
PMIx_Allocation_request_nb(pmix_alloc_directive_t directive, \\
\hspace*{27\sigspace}pmix_info_t info[], size_t ninfo, \\
\hspace*{27\sigspace}pmix_info_cbfunc_t cbfunc, void *cbdata);
}

\begin{arglist}
\argin{directive}{Allocation directive (\refstruct{pmix_alloc_directive_t})}
\argin{info}{Array of \refstruct{pmix_info_t} structures (array of handles)}
\argin{ninfo}{Number of elements in the \refarg{info} array (integer)}
\argin{cbfunc}{Callback function \refapi{pmix_info_cbfunc_t} (function reference)}
\argin{cbdata}{Data to be passed to the callback function (memory reference)}
\end{arglist}

Returns one of the following:

\returnsimplenb

\returnstart
\begin{itemize}
    \item \refconst{PMIX_OPERATION_SUCCEEDED}, indicating that the request was immediately processed and returned \textit{success} - the \refarg{cbfunc} will \textit{not} be called
\end{itemize}
\returnend

\reqattrstart
\ac{PMIx} libraries are not required to directly support any attributes for this function. However, any provided attributes must be passed to the host \ac{SMS} daemon for processing, and the \ac{PMIx} library is \textit{required} to add the \refAttributeItem{PMIX_USERID} and the \refAttributeItem{PMIX_GRPID} attributes of the client process making the request.

Host environments that implement support for this operation are required to support the following attributes:

\pasteAttributeItem{PMIX_ALLOC_REQ_ID}
\pasteAttributeItem{PMIX_ALLOC_NUM_NODES}
\pasteAttributeItem{PMIX_ALLOC_NUM_CPUS}
\pasteAttributeItem{PMIX_ALLOC_TIME}

\reqattrend

\optattrstart
The following attributes are optional for host environments that support this operation:

\pasteAttributeItem{PMIX_ALLOC_NODE_LIST}
\pasteAttributeItem{PMIX_ALLOC_NUM_CPU_LIST}
\pasteAttributeItem{PMIX_ALLOC_CPU_LIST}
\pasteAttributeItem{PMIX_ALLOC_MEM_SIZE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_ID}
\pasteAttributeItem{PMIX_ALLOC_BANDWIDTH}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_QOS}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_TYPE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_PLANE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_ENDPTS}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_ENDPTS_NODE}
\pasteAttributeItem{PMIX_ALLOC_FABRIC_SEC_KEY}

\optattrend

%%%%
\descr

Non-blocking form of the \refapi{PMIx_Allocation_request} \ac{API}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Job Allocation attributes}
\label{api:struct:attributes:joballoc}

Attributes used to describe the job allocation - these are values passed to and/or returned by the \refapi{PMIx_Allocation_request_nb} and \refapi{PMIx_Allocation_request} \acp{API} and are not accessed using the \refapi{PMIx_Get} \ac{API}.

%
\declareAttribute{PMIX_ALLOC_REQ_ID}{"pmix.alloc.reqid"}{char*}{
User-provided string identifier for this allocation request which can later be used to query status of the request.
}
%
\declareAttribute{PMIX_ALLOC_ID}{"pmix.alloc.id"}{char*}{
A string identifier (provided by the host environment) for the resulting allocation which can later be used to reference the allocated resources in, for example, a call to \refapi{PMIx_Spawn}.
}
%
\declareAttribute{PMIX_ALLOC_QUEUE}{"pmix.alloc.queue"}{char*}{
Name of the \ac{WLM} queue to which the allocation request is to be directed, or the queue being referenced in a query.
}
%
\declareAttribute{PMIX_ALLOC_NUM_NODES}{"pmix.alloc.nnodes"}{uint64_t}{
The number of nodes being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_NODE_LIST}{"pmix.alloc.nlist"}{char*}{
Regular expression of the specific nodes being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_NUM_CPUS}{"pmix.alloc.ncpus"}{uint64_t}{
Number of \acp{PU} being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_NUM_CPU_LIST}{"pmix.alloc.ncpulist"}{char*}{
Regular expression of the number of \acp{PU} for each node being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_CPU_LIST}{"pmix.alloc.cpulist"}{char*}{
Regular expression of the specific \acp{PU}  being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_MEM_SIZE}{"pmix.alloc.msize"}{float}{
Number of Megabytes[base2] of memory (per process) being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC}{"pmix.alloc.net"}{array}{
Array of \refstruct{pmix_info_t} describing requested fabric resources. This must include at least: \refattr{PMIX_ALLOC_FABRIC_ID}, \refattr{PMIX_ALLOC_FABRIC_TYPE}, and \refattr{PMIX_ALLOC_FABRIC_ENDPTS}, plus whatever other descriptors are desired.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_ID}{"pmix.alloc.netid"}{char*}{
The key to be used when accessing this requested fabric allocation. The fabric allocation will be returned/stored as a \refstruct{pmix_data_array_t} of \refstruct{pmix_info_t} whose first element is composed of this key and the allocated resource description.
The type of the included value depends upon the fabric support. For example, a \ac{TCP} allocation might consist of a comma-delimited string of socket ranges such as \code{"32000-32100,\allowbreak 33005,38123-38146"}. Additional array entries will consist of any provided resource request directives, along with their assigned values. Examples include: \refattr{PMIX_ALLOC_FABRIC_TYPE} - the type of resources provided; \refattr{PMIX_ALLOC_FABRIC_PLANE} - if applicable, what plane the resources were assigned from; \refattr{PMIX_ALLOC_FABRIC_QOS} - the assigned QoS; \refattr{PMIX_ALLOC_BANDWIDTH} - the allocated bandwidth; \refattr{PMIX_ALLOC_FABRIC_SEC_KEY} - a security key for the requested fabric allocation. NOTE: the array contents may differ from those requested, especially if \refconst{PMIX_INFO_REQD} was not set in the request.
}
%
\declareAttribute{PMIX_ALLOC_BANDWIDTH}{"pmix.alloc.bw"}{float}{
Fabric bandwidth (in Megabits[base2]/sec) for the job being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_QOS}{"pmix.alloc.netqos"}{char*}{
Fabric quality of service level for the job being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_TIME}{"pmix.alloc.time"}{uint32_t}{
Total session time (in seconds) being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_TYPE}{"pmix.alloc.nettype"}{char*}{
Type of desired transport (e.g., \var{``tcp''}, \var{``udp''}) being requested in an allocation request.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_PLANE}{"pmix.alloc.netplane"}{char*}{
ID string for the \refterm{fabric plane} to be used for the requested allocation.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_ENDPTS}{"pmix.alloc.endpts"}{size_t}{
Number of endpoints to allocate per \refterm{process} in the job.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_ENDPTS_NODE}{"pmix.alloc.endpts.nd"}{size_t}{
Number of endpoints to allocate per \refterm{node} for the job.
}
%
\declareAttribute{PMIX_ALLOC_FABRIC_SEC_KEY}{"pmix.alloc.nsec"}{pmix_byte_object_t}{
Request that the allocation include a fabric security key for the spawned job.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Job Allocation Directives}
\declarestruct{pmix_alloc_directive_t}

\versionMarker{2.0}
The \refstruct{pmix_alloc_directive_t} structure is a \code{uint8_t} type that defines the behavior of allocation requests.
The following constants can be used to set a variable of the type \refstruct{pmix_alloc_directive_t}. All definitions were introduced in version 2 of the standard unless otherwise marked.

\begin{constantdesc}
%
\declareconstitemvalue{PMIX_ALLOC_NEW}{1}
A new allocation is being requested.
The resulting allocation will be disjoint (i.e., not connected in a job sense) from the requesting allocation.
%
\declareconstitemvalue{PMIX_ALLOC_EXTEND}{2}
Extend the existing allocation, either in time or as additional resources.
%
\declareconstitemvalue{PMIX_ALLOC_RELEASE}{3}
Release part of the existing allocation.
Attributes in the accompanying \refstruct{pmix_info_t} array may be used to specify permanent release of the identified resources, or ``lending'' of those resources for some period of time.
%
\declareconstitemvalue{PMIX_ALLOC_REAQUIRE}{4}
Reacquire resources that were previously ``lent'' back to the scheduler.
%
\declareconstitemvalue{PMIX_ALLOC_EXTERNAL}{128}
A value boundary above which implementers are free to define their own directive values.
%
\end{constantdesc}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Job Control}
\label{chap:api_job_mgmt:jctrl}

This section defines \acp{API} that enable the application and host environment to coordinate the response to failures and other events.
This can include requesting termination of the entire job or a subset of processes within a job, but can
also be used in combination with other \ac{PMIx} capabilities (e.g., allocation support and event notification) for more nuanced responses. For example, an application notified of an incipient over-temperature condition on a node could use the \refapi{PMIx_Allocation_request_nb} interface to request replacement nodes while simultaneously using the \refapi{PMIx_Job_control_nb} interface to direct that a checkpoint event be delivered to all processes in the application. If replacement resources are not available, the application might use the \refapi{PMIx_Job_control_nb} interface to request that the job continue at a lower power setting, perhaps sufficient to avoid the over-temperature failure.

The job control \acp{API} can also be used by an application to register itself as available for preemption when operating in an environment such as a cloud or where incentives, financial or otherwise, are provided to jobs willing to be preempted. Registration can include attributes indicating how many resources are being offered for preemption (e.g., all or only some portion), whether the application will require time to prepare for preemption, etc. Jobs that
request a warning will receive an event notifying them of an impending preemption (possibly including information as to the resources that will be taken away, how much time the application will be given prior to being preempted, whether the preemption will be a suspension or full termination, etc.) so they have an opportunity to save
their work. Once the application is ready, it calls the provided event completion callback function to indicate that
the SMS is free to suspend or terminate it, and can include directives regarding any desired restart.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Job_control}}
\declareapi{PMIx_Job_control}

%%%%
\summary

Request a job control action.

%%%%
\format

\copySignature{PMIx_Job_control}{3.0}{
pmix_status_t \\
PMIx_Job_control(const pmix_proc_t targets[], size_t ntargets, \\
\hspace*{17\sigspace}const pmix_info_t directives[], size_t ndirs, \\
\hspace*{17\sigspace}pmix_info_t *results[], size_t *nresults);
}

\begin{arglist}
\argin{targets}{Array of proc structures (array of handles)}
\argin{ntargets}{Number of elements in the \refarg{targets} array (integer)}
\argin{directives}{Array of info structures (array of handles)}
\argin{ndirs}{Number of elements in the \refarg{directives} array (integer)}
\arginout{results}{Address where a pointer to an array of \refstruct{pmix_info_t} containing the results of the request can be returned (memory reference)}
\arginout{nresults}{Address where the number of elements in \refarg{results} can be returned (handle)}
\end{arglist}

\returnsimple

\reqattrstart
\ac{PMIx} libraries are not required to directly support any attributes for this function. However, any provided attributes must be passed to the host \ac{SMS} daemon for processing, and the \ac{PMIx} library is \textit{required} to add the \refAttributeItem{PMIX_USERID} and the \refAttributeItem{PMIX_GRPID} attributes of the client process making the request.

Host environments that implement support for this operation are required to support the following attributes:

\pasteAttributeItem{PMIX_JOB_CTRL_ID}
\pasteAttributeItem{PMIX_JOB_CTRL_PAUSE}
\pasteAttributeItem{PMIX_JOB_CTRL_RESUME}
\pasteAttributeItem{PMIX_JOB_CTRL_KILL}
\pasteAttributeItem{PMIX_JOB_CTRL_SIGNAL}
\pasteAttributeItem{PMIX_JOB_CTRL_TERMINATE}
\pasteAttributeItem{PMIX_REGISTER_CLEANUP}
\pasteAttributeItem{PMIX_REGISTER_CLEANUP_DIR}
\pasteAttributeItem{PMIX_CLEANUP_RECURSIVE}
\pasteAttributeItem{PMIX_CLEANUP_EMPTY}
\pasteAttributeItem{PMIX_CLEANUP_IGNORE}
\pasteAttributeItem{PMIX_CLEANUP_LEAVE_TOPDIR}

\reqattrend

\optattrstart
The following attributes are optional for host environments that support this operation:

\pasteAttributeItem{PMIX_JOB_CTRL_CANCEL}
\pasteAttributeItem{PMIX_JOB_CTRL_RESTART}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_EVENT}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_SIGNAL}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_TIMEOUT}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_METHOD}
\pasteAttributeItem{PMIX_JOB_CTRL_PROVISION}
\pasteAttributeItem{PMIX_JOB_CTRL_PROVISION_IMAGE}
\pasteAttributeItem{PMIX_JOB_CTRL_PREEMPTIBLE}

\optattrend

%%%%
\descr

Request a job control action.
The \refarg{targets} array identifies the processes to which the requested job control action is to be applied. All \refterm{clones} of an identified process are to have the requested action applied to them.
A \code{NULL} value can be used to indicate all processes in the caller's namespace.
The use of \refconst{PMIX_RANK_WILDCARD} can also be used to indicate that all processes in the given namespace are to be included.

The directives are provided as \refstruct{pmix_info_t} structures in the \refarg{directives} array.
The returned \refarg{status} indicates whether or not the request was granted, and information as to the reason for any denial of the request shall be returned in the \refarg{results} array.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Job_control_nb}}
\declareapi{PMIx_Job_control_nb}

%%%%
\summary

Request a job control action.

%%%%
\format

\copySignature{PMIx_Job_control_nb}{2.0}{
pmix_status_t \\
PMIx_Job_control_nb(const pmix_proc_t targets[], size_t ntargets, \\
\hspace*{20\sigspace}const pmix_info_t directives[], size_t ndirs, \\
\hspace*{20\sigspace}pmix_info_cbfunc_t cbfunc, void *cbdata);
}

\begin{arglist}
\argin{targets}{Array of proc structures (array of handles)}
\argin{ntargets}{Number of elements in the \refarg{targets} array (integer)}
\argin{directives}{Array of info structures (array of handles)}
\argin{ndirs}{Number of elements in the \refarg{directives} array (integer)}
\argin{cbfunc}{Callback function \refapi{pmix_info_cbfunc_t} (function reference)}
\argin{cbdata}{Data to be passed to the callback function (memory reference)}
\end{arglist}

\returnsimplenb

\returnstart
\begin{itemize}
    \item \refconst{PMIX_OPERATION_SUCCEEDED}, indicating that the request was immediately processed and returned \textit{success} - the \refarg{cbfunc} will \textit{not} be called
\end{itemize}
\returnend

\reqattrstart
\ac{PMIx} libraries are not required to directly support any attributes for this function. However, any provided attributes must be passed to the host \ac{SMS} daemon for processing, and the \ac{PMIx} library is \textit{required} to add the \refAttributeItem{PMIX_USERID} and the \refAttributeItem{PMIX_GRPID} attributes of the client process making the request.

Host environments that implement support for this operation are required to support the following attributes:

\pasteAttributeItem{PMIX_JOB_CTRL_ID}
\pasteAttributeItem{PMIX_JOB_CTRL_PAUSE}
\pasteAttributeItem{PMIX_JOB_CTRL_RESUME}
\pasteAttributeItem{PMIX_JOB_CTRL_KILL}
\pasteAttributeItem{PMIX_JOB_CTRL_SIGNAL}
\pasteAttributeItem{PMIX_JOB_CTRL_TERMINATE}
\pasteAttributeItem{PMIX_REGISTER_CLEANUP}
\pasteAttributeItem{PMIX_REGISTER_CLEANUP_DIR}
\pasteAttributeItem{PMIX_CLEANUP_RECURSIVE}
\pasteAttributeItem{PMIX_CLEANUP_EMPTY}
\pasteAttributeItem{PMIX_CLEANUP_IGNORE}
\pasteAttributeItem{PMIX_CLEANUP_LEAVE_TOPDIR}

\reqattrend

\optattrstart
The following attributes are optional for host environments that support this operation:

\pasteAttributeItem{PMIX_JOB_CTRL_CANCEL}
\pasteAttributeItem{PMIX_JOB_CTRL_RESTART}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_EVENT}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_SIGNAL}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_TIMEOUT}
\pasteAttributeItem{PMIX_JOB_CTRL_CHECKPOINT_METHOD}
\pasteAttributeItem{PMIX_JOB_CTRL_PROVISION}
\pasteAttributeItem{PMIX_JOB_CTRL_PROVISION_IMAGE}
\pasteAttributeItem{PMIX_JOB_CTRL_PREEMPTIBLE}

\optattrend

%%%%
\descr

Non-blocking form of the \refapi{PMIx_Job_control} \ac{API}.
The \refarg{targets} array identifies the processes to which the requested job control action is to be applied. All \refterm{clones} of an identified process are to have the requested action applied to them.
A \code{NULL} value can be used to indicate all processes in the caller's namespace.
The use of \refconst{PMIX_RANK_WILDCARD} can also be used to indicate that all processes in the given namespace are to be included.

The directives are provided as \refstruct{pmix_info_t} structures in the \refarg{directives} array.
The callback function provides a \refarg{status} to indicate whether or not the request was granted, and to provide some information as to the reason for any denial in the \refapi{pmix_info_cbfunc_t} array of \refstruct{pmix_info_t} structures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Job control constants}
\label{api:struct:constants:jobcontrol}

The following constants are specifically defined for return by the job control \acp{API}:

\begin{constantdesc}

%
\declareconstitemvalue{PMIX_ERR_CONFLICTING_CLEANUP_DIRECTIVES}{-51}
Conflicting directives given for job/process cleanup.

\end{constantdesc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Job control events}
\label{api:struct:events:jobcontrol}

The following job control events may be available for registration, depending upon implementation and host environment support:

\begin{constantdesc}
%
\declareconstitemvalue{PMIX_JCTRL_CHECKPOINT}{-106}
Monitored by \ac{PMIx} client to trigger a checkpoint operation.
%
\declareconstitemvalue{PMIX_JCTRL_CHECKPOINT_COMPLETE}{-107}
Sent by a \ac{PMIx} client and monitored by a \ac{PMIx} server to notify that requested checkpoint operation has completed.
%
\declareconstitemvalue{PMIX_JCTRL_PREEMPT_ALERT}{-108}
Monitored by a \ac{PMIx} client to detect that an \ac{RM} intends to preempt the job.
%
\declareconstitemvalue{PMIX_ERR_PROC_RESTART}{-4}
Error in process restart.
%
\declareconstitemvalue{PMIX_ERR_PROC_CHECKPOINT}{-5}
Error in process checkpoint.
%
\declareconstitemvalue{PMIX_ERR_PROC_MIGRATE}{-6}
Error in process migration.
%
\end{constantdesc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Job control attributes}
\label{api:struct:attributes:jobcontrol}

Attributes used to request control operations on an executing application - these are values passed to the job control \acp{API} and are not accessed using the \refapi{PMIx_Get} \ac{API}.

%
\declareAttribute{PMIX_JOB_CTRL_ID}{"pmix.jctrl.id"}{char*}{
Provide a string identifier for this request. The user can provide an identifier for the requested operation, thus allowing them to later request status of the operation or to terminate it. The host, therefore, shall track it with the request for future reference.
}
%
\declareAttribute{PMIX_JOB_CTRL_PAUSE}{"pmix.jctrl.pause"}{bool}{
Pause the specified processes.
}
%
\declareAttribute{PMIX_JOB_CTRL_RESUME}{"pmix.jctrl.resume"}{bool}{
Resume (``un-pause'') the specified processes.
}
%
\declareAttribute{PMIX_JOB_CTRL_CANCEL}{"pmix.jctrl.cancel"}{char*}{
Cancel the specified request - the provided request ID must match the \refattr{PMIX_JOB_CTRL_ID} provided to a previous call to \refapi{PMIx_Job_control}. An ID of \code{NULL} implies cancel all requests from this requestor.
}
%
\declareAttribute{PMIX_JOB_CTRL_KILL}{"pmix.jctrl.kill"}{bool}{
Forcibly terminate the specified processes and cleanup.
}
%
\declareAttribute{PMIX_JOB_CTRL_RESTART}{"pmix.jctrl.restart"}{char*}{
Restart the specified processes using the given checkpoint ID.
}
%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT}{"pmix.jctrl.ckpt"}{char*}{
Checkpoint the specified processes and assign the given ID to it.
}
%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_EVENT}{"pmix.jctrl.ckptev"}{bool}{
Use event notification to trigger a process checkpoint.
}
%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_SIGNAL}{"pmix.jctrl.ckptsig"}{int}{
Use the given signal to trigger a process checkpoint.
}
%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_TIMEOUT}{"pmix.jctrl.ckptsig"}{int}{
Time in seconds to wait for a checkpoint to complete.
}
%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_METHOD}{"pmix.jctrl.ckmethod"}{pmix_data_array_t}{
Array of \refstruct{pmix_info_t} declaring each method and value supported by this application.
}
%
\declareAttribute{PMIX_JOB_CTRL_SIGNAL}{"pmix.jctrl.sig"}{int}{
Send given signal to specified processes.
}
%
\declareAttribute{PMIX_JOB_CTRL_PROVISION}{"pmix.jctrl.pvn"}{char*}{
Regular expression identifying nodes that are to be provisioned.
}
%
\declareAttribute{PMIX_JOB_CTRL_PROVISION_IMAGE}{"pmix.jctrl.pvnimg"}{char*}{
Name of the image that is to be provisioned.
}
%
\declareAttribute{PMIX_JOB_CTRL_PREEMPTIBLE}{"pmix.jctrl.preempt"}{bool}{
Indicate that the job can be pre-empted.
}
%
\declareAttribute{PMIX_JOB_CTRL_TERMINATE}{"pmix.jctrl.term"}{bool}{
Politely terminate the specified processes.
}
%
\declareAttribute{PMIX_REGISTER_CLEANUP}{"pmix.reg.cleanup"}{char*}{
Comma-delimited list of files to be removed upon process termination.
}
%
\declareAttribute{PMIX_REGISTER_CLEANUP_DIR}{"pmix.reg.cleanupdir"}{char*}{
Comma-delimited list of directories to be removed upon process termination.
}
%
\declareAttribute{PMIX_CLEANUP_RECURSIVE}{"pmix.clnup.recurse"}{bool}{
Recursively cleanup all subdirectories under the specified one(s).
}
%
\declareAttribute{PMIX_CLEANUP_EMPTY}{"pmix.clnup.empty"}{bool}{
Only remove empty subdirectories.
}
%
\declareAttribute{PMIX_CLEANUP_IGNORE}{"pmix.clnup.ignore"}{char*}{
Comma-delimited list of filenames that are not to be removed.
}
%
\declareAttribute{PMIX_CLEANUP_LEAVE_TOPDIR}{"pmix.clnup.lvtop"}{bool}{
When recursively cleaning subdirectories, do not remove the top-level directory (the one given in the cleanup request).
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process and Job Monitoring}
\label{chap:api_job_mgmt:monitor}

In addition to external faults, a common problem encountered in \ac{HPC} applications is a failure to make
progress due to some internal conflict in the computation. These situations can
result in a significant waste of resources as the \ac{SMS} is unaware of the problem, and thus cannot terminate the
job. Various watchdog methods have been developed for detecting this situation, including requiring a periodic ``heartbeat''
from the application and monitoring a specified file for changes in size and/or modification time.

The following \acp{API} allow applications to request monitoring, directing what is to be monitored, the frequency of the associated check, whether or not the application is to be notified (via the event notification subsystem) of stall detection, and other characteristics of the operation. In addition, statistics on the resource usage at the individual process level and/or overall node level (including usage information on disks and/or network interfaces) can be measured and periodically reported back to the requestor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Process_monitor}}
\declareapi{PMIx_Process_monitor}

%%%%
\summary

Request that application processes be monitored.

%%%%
\format

\copySignature{PMIx_Process_monitor}{3.0}{
pmix_status_t \\
PMIx_Process_monitor(const pmix_info_t *monitor, \\
\hspace*{21\sigspace}pmix_status_t error, \\
\hspace*{21\sigspace}const pmix_info_t directives[], size_t ndirs, \\
\hspace*{21\sigspace}pmix_info_t *results[], size_t *nresults);
}

\begin{arglist}
\argin{monitor}{Pointer to \refstruct{pmix_info_t} specifying monitoring action (handle)}
\argin{error}{\ac{PMIx} constant that is to be used when generating an associated monitoring event (integer)}
\argin{directives}{Array of info structures (array of handles)}
\argin{ndirs}{Number of elements in the \refarg{directives} array (integer)}
\arginout{results}{Address where a pointer to an array of \refstruct{pmix_info_t} containing the results of the request can be returned (memory reference)}
\arginout{nresults}{Address where the number of elements in \refarg{results} can be returned (handle)}
\end{arglist}

A successful return indicates that the results have been placed in the \refarg{results} array.

\returnsimple

\optattrstart
The following attributes may be implemented by a \ac{PMIx} library or by the host environment. If an attribute is supported by the \ac{PMIx} server library, then the library must not pass the supported attributes to the host environment unless the requested action involves other nodes. In addition, the library is \textit{required} to add the \refAttributeItem{PMIX_USERID} and the \refAttributeItem{PMIX_GRPID} attributes of the requesting process to the directives array when it passes actions to its host.

The \refarg{monitor} argument may contain any of the following actions:

\begin{itemize}
    \item \refattr{PMIX_MONITOR_CANCEL}
    \item \refattr{PMIX_MONITOR_HEARTBEAT} The associated \refarg{directives} array may include any of the following:
    \begin{itemize}
        \item \refattr{PMIX_MONITOR_HEARTBEAT_TIME}
        \item \refattr{PMIX_MONITOR_HEARTBEAT_DROPS}
    \end{itemize}
    \item \refattr{PMIX_SEND_HEARTBEAT}
    \item \refattr{PMIX_MONITOR_FILE_CHANGES} The associated \refarg{directives} array may include any of the following:
    \begin{itemize}
        \item \refattr{PMIX_MONITOR_FILE_CHECK_TIME}
        \item \refattr{PMIX_MONITOR_FILE_DROPS}
        \item \refattr{PMIX_MONITOR_TARGET_FILES}
        \item \refattr{PMIX_MONITOR_TARGET_NODES}. Monitor the given files on the specified nodes, where present.
        \item \refattr{PMIX_MONITOR_TARGET_NODEIDS}. Monitor the given files on the specified nodes, where present.
    \end{itemize}
    \item \refattr{PMIX_MONITOR_PROC_RESOURCE_USAGE} The associated \refarg{directives} array may include any of the following:
    \begin{itemize}
        \item \refattr{PMIX_MONITOR_RESOURCE_RATE}
        \item \refattr{PMIX_MONITOR_TARGET_PROCS}
        \item \refattr{PMIX_MONITOR_TARGET_PIDS}
        \item \refattr{PMIX_MONITOR_TARGET_NODES}. All processes on the specified nodes are to be monitored.
        \item \refattr{PMIX_MONITOR_TARGET_NODEIDS}. All processes on the specified nodes are to be monitored.
    \end{itemize}
    \item \refattr{PMIX_MONITOR_NODE_RESOURCE_USAGE} The associated \refarg{directives} array may include any of the following:
    \begin{itemize}
        \item \refattr{PMIX_MONITOR_RESOURCE_RATE}
        \item \refattr{PMIX_MONITOR_TARGET_NODES}
        \item \refattr{PMIX_MONITOR_TARGET_NODEIDS}
        \item \refattr{PMIX_MONITOR_TARGET_PROCS}. Monitor the nodes where the specified processes are located.
    \end{itemize}
    \item \refattr{PMIX_MONITOR_DISK_RESOURCE_USAGE} The associated \refarg{directives} array may include any of the following:
    \begin{itemize}
        \item \refattr{PMIX_MONITOR_RESOURCE_RATE}
        \item \refattr{PMIX_MONITOR_TARGET_DISKS}
        \item \refattr{PMIX_MONITOR_TARGET_NODES}
        \item \refattr{PMIX_MONITOR_TARGET_NODEIDS}
        \item \refattr{PMIX_MONITOR_TARGET_PROCS}. Monitor the nodes where the specified processes are located.
    \end{itemize}
    \item \refattr{PMIX_MONITOR_NETWORK_RESOURCE_USAGE} The associated \refarg{directives} array may include any of the following:
    \begin{itemize}
        \item \refattr{PMIX_MONITOR_RESOURCE_RATE}
        \item \refattr{PMIX_MONITOR_TARGET_NETS}
        \item \refattr{PMIX_MONITOR_TARGET_NODES}
        \item \refattr{PMIX_MONITOR_TARGET_NODEIDS}
        \item \refattr{PMIX_MONITOR_TARGET_PROCS}. Monitor the nodes where the specified processes are located.
    \end{itemize}
\end{itemize}

In addition to action-specific directives, the \refarg{directives} array may include:

\begin{itemize}
    \item \refattr{PMIX_MONITOR_ID}
    \item \refattr{PMIX_MONITOR_APP_CONTROL}
    \item \refattr{PMIX_RANGE} Non-default range to be used when generating the associated event for this monitoring action.
    \item \refattr{PMIX_MONITOR_LOCAL_ONLY}
\end{itemize}
\optattrend

%%%%
\descr

This \ac{API} can be used for two purposes:

\begin{itemize}
    \item Request that application processes and/or files be monitored for activity via several possible methods. For example, that the server monitor a given process for periodic heartbeats as an indication that the process has not become ``wedged''. When a monitor detects the specified alarm condition, it will generate an event notification using the provided error code and passing along any available relevant information. It is up to the caller to register a corresponding event handler.
    \item Report resource usage statistics for processes and/or nodes, including disk and network interfaces attached to nodes. This can be done on a per-request basis, or periodically updated on a time interval specified by the \refattr{PMIX_MONITOR_RESOURCE_RATE} attribute.
\end{itemize}

The \refarg{monitor} argument is an attribute indicating the type of monitor being requested.
For example, \refattr{PMIX_MONITOR_FILE_CHANGES} to indicate that the requestor is asking that a file be monitored, or \refattr{PMIX_MONITOR_PROC_RESOURCE_USAGE} to obtain a report on process resource usage.

The \refarg{error} argument is the status code to be used when generating an event notification alerting that the monitor has been triggered or to receive a periodic resource usage update.
The range of the notification defaults to \refconst{PMIX_RANGE_NAMESPACE} for alarm events, and to \refconst{PMIX_RANGE_CUSTOM} for resource usage updates to ensure delivery solely to the requesting process. This can be changed by providing a \refattr{PMIX_RANGE} directive.

The \refarg{directives} argument characterizes the monitoring request (e.g., monitor file size or specific resource usage metrics to be measured) and frequency of checking to be done.

The returned \refarg{status} indicates whether or not the request was granted, and information as to the reason for any denial of the request shall be returned in the \refarg{results} array. If the request was successful, then any measured values will be returned in the \refarg{results}.

\adviceuserstart
A \refconst{PMIX_SUCCESS} return status only indicates that no error was encountered when executing the request and does not guarantee a non-\code{NULL} value for \refarg{results} when requesting resource usage statistics. For example, a request for resource usage by processes on a specified node that is not currently executing any user-level processes will return success to indicate that the request was executed without error, but a \code{NULL} \refarg{results} array because no statistics were returned.
\adviceuserend

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Process_monitor_nb}}
\declareapi{PMIx_Process_monitor_nb}

%%%%
\summary

Request that application processes be monitored.

%%%%
\format

\copySignature{PMIx_Process_monitor_nb}{2.0}{
pmix_status_t \\
PMIx_Process_monitor_nb(const pmix_info_t *monitor, \\
\hspace*{24\sigspace}pmix_status_t error, \\
\hspace*{24\sigspace}const pmix_info_t directives[], \\
\hspace*{24\sigspace}size_t ndirs, \\
\hspace*{24\sigspace}pmix_info_cbfunc_t cbfunc, void *cbdata);
}

\begin{arglist}
\argin{monitor}{Pointer to \refstruct{pmix_info_t} specifying monitoring action (handle)}
\argin{error}{\ac{PMIx} constant that is to be used when generating an associated monitoring event (integer)}
\argin{directives}{Array of info structures (array of handles)}
\argin{ndirs}{Number of elements in the \refarg{directives} array (integer)}
\argin{cbfunc}{Callback function \refapi{pmix_info_cbfunc_t} (function reference)}
\argin{cbdata}{Data to be passed to the callback function (memory reference)}
\end{arglist}

Returns one of the following:

\returnsimplenb

\returnstart
\begin{itemize}
    \item \refconst{PMIX_OPERATION_SUCCEEDED}, indicating that the request was immediately processed and returned \textit{success} - the \refarg{cbfunc} will \textit{not} be called, and no resource usage results will be returned by the \ac{API} itself.
\end{itemize}
\returnend

%%%%
\descr

Non-blocking form of the \refapi{PMIx_Process_monitor} \ac{API}. The \refarg{cbfunc} function provides a \refarg{status} to indicate whether or not the request was granted, and to provide some information as to the reason for any denial in the \refapi{pmix_info_cbfunc_t} array of \refstruct{pmix_info_t} structures. Any resource usage data generated by the function will be returned there as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Heartbeat}}
\declareapiProvisional{PMIx_Heartbeat}

%%%%
\summary

Send a heartbeat to the \ac{PMIx} server library

%%%%
\format

\copySignature{PMIx_Heartbeat}{6.0}{
void \\
PMIx_Heartbeat(\code{void});
}


%%%%
\descr

A simplified function wrapping \refapi{PMIx_Process_monitor_nb} that sends a heartbeat to the \ac{PMIx} server library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Monitoring events}
\label{api:struct:events:monitor}

The following monitoring events may be available for registration, depending upon implementation and host environment support:

\begin{constantdesc}
%
\declareconstitemvalue{PMIX_MONITOR_HEARTBEAT_ALERT}{-109}
Heartbeat failed to arrive within specified window. The process that triggered this alert will be identified in the event.
%
\declareconstitemvalue{PMIX_MONITOR_FILE_ALERT}{-110}
File failed its monitoring detection criteria. The file that triggered this alert will be identified in the event.
%
\declareconstitemvalueProvisional{PMIX_MONITOR_RESUSAGE_UPDATE}{-112}
Resource usage update - the report will be included in the event information.
%
\end{constantdesc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Monitoring Datatypes}

The following datatype definitions have been created to support monitoring operations and information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Node PID Structure}
\declarestructProvisional{pmix_node_pid_t}

The \refstruct{pmix_node_pid_t} structure contains the hostname (or nodeID) and pid of a process executing on that host.
Since a pid is uniquely associated with a given host, this creates a conjugate pair.

\copySignature{pmix_node_pid_t}{6.0}{
typedef struct pmix_node_pid \{ \\
\hspace*{4\sigspace}char *hostname; \\
\hspace*{4\sigspace}uint32_t nodeid; \\
\hspace*{4\sigspace}pid_t pid; \\
\} pmix_node_pid_t;
}

The \refarg{pid} field contains the \code{pid_t} of the process, while the \refarg{hostname} and/or \refarg{nodeid} identify the node where the process is executing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Node PID support functions}

The following functions are provided for convenience when working with \refstruct{pmix_node_pid_t} structures.

\littleheader{Initialize the node_pid structure}
\declareapiProvisional{PMIx_Nodepid_construct}

Initialize the \refstruct{pmix_node_pid_t} fields.

\copySignature{PMIx_Nodepid_construct}{6.0}{
void
PMIx_Nodepid_construct(pmix_node_pid_t *p);
}

\begin{arglist}
\argin{p}{Pointer to the structure to be initialized(pointer to \refstruct{pmix_node_pid_t})}
\end{arglist}

\littleheader{Destruct the node_pid structure}
\declareapiProvisional{PMIx_Nodepid_destruct}

Destruct the \refstruct{pmix_node_pid_t} fields.

\copySignature{PMIx_Nodepid_destruct}{6.0}{
void
PMIx_Nodepid_destruct(pmix_node_pid_t *p);
}

\begin{arglist}
\argin{p}{Pointer to the structure to be destructed (pointer to \refstruct{pmix_node_pid_t})}
\end{arglist}

\littleheader{Create an array of node_pid structures}
\declareapiProvisional{PMIx_Nodepid_create}

Allocate and initialize an array of \refstruct{pmix_node_pid_t} structures.

\copySignature{PMIx_Nodepid_create}{6.0}{
pmix_node_pid_t*
PMIx_Nodepid_create(size_t n);
}

\begin{arglist}
\argin{n}{Number of \refstruct{pmix_node_pid_t} structures to allocate}
\end{arglist}

Returns \refstruct{pmix_node_pid_t} pointer to the allocated array

\littleheader{Release an array of node_pid structures}
\declareapiProvisional{PMIx_Nodepid_free}

Free all allocated memory in an array of \refstruct{pmix_node_pid_t} structures.

\copySignature{PMIx_Nodepid_free}{6.0}{
void
PMIx_Nodepid_free(pmix_node_pid_t *p,
\hspace*{4\sigspace}size_t n);
}

\begin{arglist}
\argin{p}{Pointer to the array to be released (pointer to \refstruct{pmix_node_pid_t})}
\argin{n}{Number of \refstruct{pmix_node_pid_t} structures in array}
\end{arglist}


%%%%%%%%%%%
\subsection{Monitoring attributes}
\label{api:struct:attributes:monitor}

Attributes used to control monitoring of an executing application- these are values passed to the \refapi{PMIx_Process_monitor_nb} \ac{API} and are not accessed using the \refapi{PMIx_Get} \ac{API}.

%
\declareAttribute{PMIX_MONITOR_ID}{"pmix.monitor.id"}{char*}{
Provide a string identifier for this request.
}
%
\declareAttribute{PMIX_MONITOR_CANCEL}{"pmix.monitor.cancel"}{char*}{
Identifier to be canceled (\code{NULL} means cancel all monitoring for this process).
}
%
\declareAttribute{PMIX_MONITOR_APP_CONTROL}{"pmix.monitor.appctrl"}{bool}{
The application desires to control the response to a monitoring event - i.e., the application is requesting that the host environment not take immediate action in response to the event (e.g., terminating the job).
}
%
\declareAttribute{PMIX_MONITOR_HEARTBEAT}{"pmix.monitor.mbeat"}{void}{
Register to have the PMIx server monitor the requestor for heartbeats.
}
%
\declareAttribute{PMIX_SEND_HEARTBEAT}{"pmix.monitor.beat"}{void}{
Send heartbeat to local PMIx server.
}
%
\declareAttribute{PMIX_MONITOR_HEARTBEAT_TIME}{"pmix.monitor.btime"}{uint32_t}{
Time in seconds before declaring heartbeat missed.
}
%
\declareAttribute{PMIX_MONITOR_HEARTBEAT_DROPS}{"pmix.monitor.bdrop"}{uint32_t}{
Number of heartbeats that can be missed before generating the event.
}
%
\declareAttributeProvisional{PMIX_MONITOR_FILE_CHANGES}{"pmix.monitor.fchg"}{pmix_data_array_t*}{
Monitor the file characteristics specified in the provided \refstruct{pmix_data_array_t} of \refstruct{pmix_info_t}. If the provided array
is \code{NULL}, then all optional file characteristics shall be monitored. Target filenames **must** be provided in the associated
\refarg{directives} array. If no target nodes are specified, then the target files will be monitored on all nodes in the session where they are present.  Note that the values in the provided structures will be
ignored (i.e., only the attribute keys are relevant) except where noted. Optional
attributes include:

    \begin{itemize}
        \item \refattr{PMIX_MONITOR_FILE_SIZE}
        \item \refattr{PMIX_MONITOR_FILE_ACCESS}
        \item \refattr{PMIX_MONITOR_FILE_MODIFY}
    \end{itemize}
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_FILES}{"pmix.monitor.fmon"}{pmix_data_array_t*}{
Array of string filenames to be monitored for signs of life.
}
%
\declareAttribute{PMIX_MONITOR_FILE_SIZE}{"pmix.monitor.fsize"}{bool}{
Monitor that file is growing in size to determine if the application is running.
}
%
\declareAttribute{PMIX_MONITOR_FILE_ACCESS}{"pmix.monitor.faccess"}{bool}{
Monitor that time since last access has changed to determine if the application is running.
}
%
\declareAttribute{PMIX_MONITOR_FILE_MODIFY}{"pmix.monitor.fmod"}{bool}{
Monitor that time since last modified has changed to determine if the application is running.
}
%
\declareAttribute{PMIX_MONITOR_FILE_CHECK_TIME}{"pmix.monitor.ftime"}{uint32_t}{
Time in seconds between checking the file.
}
%
\declareAttribute{PMIX_MONITOR_FILE_DROPS}{"pmix.monitor.fdrop"}{uint32_t}{
Number of file checks that can be missed before generating the event.
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_PROCS}{"pmix.monitor.tgtproc"}{pmix_data_array_t*}{
Arrray of process IDs specifying the processes to be monitored. Can include a
\refconst{PMIX_RANK_WILDCARD} to indicate that all processes
from a given namespace are to be included. If omitted, then
all processes in the session will be monitored. May be included
multiple times to fully specify all processes to be included.
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_PIDS}{"pmix.monitor.tgtpid"}{pmix_data_array_t*}{
Array of \refstruct{pmix_node_pid_t} structures to be monitored. Can include a
structure containing a hostname with a pid value of \code{-1} to indicate all
processes on that node are to be included. May be included
multiple times to fully specify all processes to be included.
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_NODES}{"pmix.monitor.tgtnode"}{pmix_data_array_t*}{
Array of string host names to be monitored
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_NODEIDS}{"pmix.monitor.tgtndids"}{pmix_data_array_t*}{
Array of node IDs (\code{uint32_t}) to be monitored
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_DISKS}{"pmix.monitor.tgtdks"}{pmix_data_array_t*}{
Array of strings representing \refattr{PMIX_DISK_ID}s to be monitored
}
%
\declareAttributeProvisional{PMIX_MONITOR_TARGET_NETS}{"pmix.monitor.tgtnets"}{pmix_data_array_t*}{
Array of strings representing \refattr{PMIX_NETWORK_ID}s to be monitored
}
%
\declareAttributeProvisional{PMIX_MONITOR_RESOURCE_RATE}{"pmix.monitor.resrate"}{uint32_t}{
Monitor resource usage every N seconds, where N is the value provided by the attribute.
}
%
\declareAttributeProvisional{PMIX_MONITOR_LOCAL_ONLY}{"pmix.monitor.local"}{bool}{
Restrict data collection to the local host, regardless of any provided targets
}
%
\declareAttributeProvisional{PMIX_MONITOR_PROC_RESOURCE_USAGE}{"pmix.monitor.presuse"}{pmix_data_array_t*}{
Monitor the resources specified in the provided \refstruct{pmix_data_array_t} of \refstruct{pmix_info_t}. If the provided array
is \code{NULL}, then all resources shall be monitored. If no targets are provided in the associated
\refarg{directives} array, then
all processes in the session will be monitored.  Note that the values in the provided structures will be
ignored (i.e., only the attribute keys are relevant) except where noted, and that the
\refattr{PMIX_PROC_SAMPLE_TIME} will always be included in the returned data (there is no
need to include it in the request). Optional
attributes include:

    \begin{itemize}
        \item \refattr{PMIX_HOSTNAME}. Report the hostname where the process is located.
        \item \refattr{PMIX_NODEID}. Report the node ID where the process is located.
        \item \refattr{PMIX_PROC_PID}
        \item \refattr{PMIX_PROC_OS_STATE}
        \item \refattr{PMIX_PROC_TIME}
        \item \refattr{PMIX_PROC_PERCENT_CPU}
        \item \refattr{PMIX_PROC_PRIORITY}
        \item \refattr{PMIX_PROC_NUM_THREADS}
        \item \refattr{PMIX_PROC_PSS}
        \item \refattr{PMIX_PROC_VSIZE}
        \item \refattr{PMIX_PROC_RSS}
        \item \refattr{PMIX_PROC_PEAK_VSIZE}
        \item \refattr{PMIX_PROC_CPU}
        \item \refattr{PMIX_PROC_SAMPLE_TIME}.
    \end{itemize}
}
%
\declareAttributeProvisional{PMIX_MONITOR_NODE_RESOURCE_USAGE}{"pmix.monitor.ndresuse"}{pmix_data_array_t*}{
Monitor the resources specified in the provided \refstruct{pmix_data_array_t} of \refstruct{pmix_info_t}. If the provided array
is \code{NULL}, then all resources shall be monitored. If no targets are provided in the associated
\refarg{directives} array, then
all nodes in the session will be monitored. Note that the values in the provided structures will be
ignored (i.e., only the attribute keys are relevant) except where noted, and that the
\refattr{PMIX_NODE_SAMPLE_TIME} will always be included in the returned data (there is no
need to include it in the request). Optional
attributes include:

    \begin{itemize}
        \item \refattr{PMIX_NODE_LOAD_AVG}
        \item \refattr{PMIX_NODE_LOAD_AVG5}
        \item \refattr{PMIX_NODE_LOAD_AVG15}
        \item \refattr{PMIX_NODE_MEM_TOTAL}
        \item \refattr{PMIX_NODE_MEM_FREE}
        \item \refattr{PMIX_NODE_MEM_BUFFERS}
        \item \refattr{PMIX_NODE_MEM_CACHED}
        \item \refattr{PMIX_NODE_MEM_SWAP_CACHED}
        \item \refattr{PMIX_NODE_MEM_SWAP_TOTAL}
        \item \refattr{PMIX_NODE_MEM_SWAP_FREE}
        \item \refattr{PMIX_NODE_MEM_MAPPED}
        \item \refattr{PMIX_NODE_SAMPLE_TIME}.
    \end{itemize}
}

\declareAttributeProvisional{PMIX_MONITOR_DISK_RESOURCE_USAGE}{"pmix.monitor.dkresuse"}{pmix_data_array_t*}{
Monitor the resources specified in the provided \refstruct{pmix_data_array_t} of \refstruct{pmix_info_t}. If the provided array
is \code{NULL}, then all disk resources shall be monitored. If no \refattr{PMIX_DISK_ID} targets are provided in the associated
\refarg{directives} array, then
all disks on the local node (or on the specified target nodes, if given) will be monitored. Note that the values in the provided structures will be
ignored (i.e., only the attribute keys are relevant) except where noted, and that the
\refattr{PMIX_DISK_SAMPLE_TIME} will always be included in the returned data (there is no
need to include it in the request). Optional attributes include:

    \begin{itemize}
        \item \refattr{PMIX_DISK_READ_COMPLETED}
        \item \refattr{PMIX_DISK_READ_MERGED}
        \item \refattr{PMIX_DISK_READ_SECTORS}
        \item \refattr{PMIX_DISK_READ_MILLISEC}
        \item \refattr{PMIX_DISK_WRITE_COMPLETED}
        \item \refattr{PMIX_DISK_WRITE_MERGED}
        \item \refattr{PMIX_DISK_WRITE_SECTORS}
        \item \refattr{PMIX_DISK_WRITE_MILLISEC}
        \item \refattr{PMIX_DISK_IO_IN_PROGRESS}
        \item \refattr{PMIX_DISK_IO_MILLISEC}
        \item \refattr{PMIX_DISK_IO_WEIGHTED}
        \item \refattr{PMIX_DISK_SAMPLE_TIME}
    \end{itemize}
}

\declareAttributeProvisional{PMIX_MONITOR_NETWORK_RESOURCE_USAGE}{"pmix.monitor.netresuse"}{pmix_data_array_t*}{
Monitor the resources specified in the provided \refstruct{pmix_data_array_t} of \refstruct{pmix_info_t}. If the provided array
is \code{NULL}, then all network resources shall be monitored. If no \refattr{PMIX_NETWORK_ID} targets are provided in the associated
\refarg{directives} array, then
all network interfaces on the local node (or on the specified target nodes, if given) will be monitored. Note that the values in the provided structures will be
ignored (i.e., only the attribute keys are relevant) except where noted, and that the
\refattr{PMIX_NET_SAMPLE_TIME} will always be included in the returned data (there is no
need to include it in the request). Optional attributes include:

    \begin{itemize}
        \item \refattr{PMIX_NET_RECVD_BYTES}
        \item \refattr{PMIX_NET_RECVD_PCKTS}
        \item \refattr{PMIX_NET_RECVD_ERRS}
        \item \refattr{PMIX_NET_SENT_BYTES}
        \item \refattr{PMIX_NET_SENT_PCKTS}
        \item \refattr{PMIX_NET_SENT_ERRS}
        \item \refattr{PMIX_NET_SAMPLE_TIME}.
    \end{itemize}
}

%%%%%%%%%%%
\versionMarkerProvisional{6.0}
\subsection{Resource usage attributes}
\label{api:struct:attributes:resusage}

Operating systems typically maintain a running measure of resource utilization by active processes,
attached disks, and local network interfaces.
Though the precise values being tracked can vary by \ac{OS} flavor and local configuration, the following
attributes are defined to provide a means for requesting and returning the available metrics.

\subsubsection{Process resource usage}

\declareAttributeProvisional{PMIX_PROC_RESOURCE_USAGE}{"pmix.proc.res"}{pmix_data_array_t*}{
An array of \refstruct{pmix_info_t} describing the resource usage of the specified process, with
the first element containing the ID of the process (marked by either the \refattr{PMIX_PROCID}
or \refattr{PMIX_PROC_PID} key)
whose usage is reported in the array. The list of included information may vary across
implementations and \acp{OS}, depending upon availability and access restrictions, and the
provided list of requested values. Except for
the process ID as the first element, ordering of information in the array is arbitrary.
}

Optional information that may be included (see \href{https://www.kernel.org/doc/html/latest/filesystems/proc.html}{PROCSTATS} for a detailed description of the following fields):
\begin{itemize}
\item \refattr{PMIX_PROCID}
\item \refattr{PMIX_PROC_PID}
\item \refattr{PMIX_HOSTNAME}
\item \refattr{PMIX_NODEID}
\item \refattr{PMIX_CMD_LINE}. Typically limited solely to the argv[0] for the process
\item \declareAttributeProvisional{PMIX_PROC_OS_STATE}{"pmix.proc.osstate"}{char*}{
    The state of the process as reported by the \ac{OS} - for Linux, this is expressed as a single character.
}
\item \declareAttributeProvisional{PMIX_PROC_TIME}{"pmix.proc.time"}{struct timeval}{
    Cumulative CPU time
}
\item \declareAttributeProvisional{PMIX_PROC_PERCENT_CPU}{"pmix.proc.pcpu"}{float}{
    Percent cpu utilization by the process. Often, it is the CPU time used divided by the time the process has
    been running (cputime/realtime ratio), expressed as a percentage.
}
\item \declareAttributeProvisional{PMIX_PROC_PRIORITY}{"pmix.proc.pri"}{int32_t}{
    Priority of the process.  Higher number means higher priority.
}
\item \declareAttributeProvisional{PMIX_PROC_NUM_THREADS}{"pmix.proc.nthr"}{uint16_t}{
    Number of threads operating in the process
}
\item \declareAttributeProvisional{PMIX_PROC_PSS}{"pmix.proc.pss"}{float}{
    Proportional share size, the non-swapped physical memory, with shared memory
    proportionally accounted to all tasks mapping it (MBytes)
}
\item \declareAttributeProvisional{PMIX_PROC_VSIZE}{"pmix.proc.vsize"}{float}{
    Virtual memory size of the process (MBytes)
}
\item \declareAttributeProvisional{PMIX_PROC_RSS}{"pmix.proc.rss"}{float}{
    Resident set size, the non-swapped physical memory that a task has used (MBytes)
}
\item \declareAttributeProvisional{PMIX_PROC_PEAK_VSIZE}{"pmix.proc.pkvsize"}{float}{
    Peak virtual memory size of the process (MBytes)
}
\item \declareAttributeProvisional{PMIX_PROC_CPU}{"pmix.proc.cpu"}{uint16_t}{
    Processor that process last executed on
}
\item \declareAttributeProvisional{PMIX_PROC_SAMPLE_TIME}{"pmix.proc.samptime"}{time_t}{
    Time when sample was taken
}
\end{itemize}


\subsubsection{Disk resource usage}

\declareAttributeProvisional{PMIX_DISK_ID}{"pmix.disk.id"}{char*}{
String identifier of a disk
}

\declareAttributeProvisional{PMIX_DISK_RESOURCE_USAGE}{"pmix.disk.res"}{pmix_data_array_t*}{
An array of \refstruct{pmix_info_t} describing the resource usage of the specified disk, with
the first element containing the string name of the disk (marked by the \refattr{PMIX_DISK_ID} key)
whose usage is reported in the array. The list of included information may vary across
implementations and \acp{OS}, depending upon availability and access restrictions, and the
provided list of requested values. Except for
the disk ID as the first element, ordering of information in the array is arbitrary.
}

Optional information that may be included (see \href{https://www.kernel.org/doc/html/latest/admin-guide/iostats.html)}{IOSTATS} for a detailed description of the following fields):
\begin{itemize}
\item \refattr{PMIX_DISK_ID}
\item \declareAttributeProvisional{PMIX_DISK_READ_COMPLETED}{"pmix.disk.rdscomp"}{uint64_t}{
Number of completed read operations
}
\item \declareAttributeProvisional{PMIX_DISK_READ_MERGED}{"pmix.disk.rdsmrgd"}{uint64_t}{
Number of merged reads
}
\item \declareAttributeProvisional{PMIX_DISK_READ_SECTORS}{"pmix.disk.rdsct"}{uint64_t}{
Number of sectors read
}
\item \declareAttributeProvisional{PMIX_DISK_READ_MILLISEC}{"pmix.disk.rdms"}{uint64_t}{
Number of milliseconds spent reading the disk
}
\item \declareAttributeProvisional{PMIX_DISK_WRITE_COMPLETED}{"pmix.disk.wtscomp"}{uint64_t}{
Number of completed write operations
}
\item \declareAttributeProvisional{PMIX_DISK_WRITE_MERGED}{"pmix.disk.wtsmrgd"}{uint64_t}{
Number of merged write operations
}
\item \declareAttributeProvisional{PMIX_DISK_WRITE_SECTORS}{"pmix.disk.wtsct"}{uint64_t}{
Number of sectors written
}
\item \declareAttributeProvisional{PMIX_DISK_WRITE_MILLISEC}{"pmix.disk.wtms"}{uint64_t}{
Number of milliseconds spent writing to the disk
}
\item \declareAttributeProvisional{PMIX_DISK_IO_IN_PROGRESS}{"pmix.disk.ios"}{uint64_t}{
Number of disk IO operations in progress
}
\item \declareAttributeProvisional{PMIX_DISK_IO_MILLISEC}{"pmix.disk.ioms"}{uint64_t}{
Number of milliseconds spent in IO operations
}
\item \declareAttributeProvisional{PMIX_DISK_IO_WEIGHTED}{"pmix.disk.iowght"}{uint64_t}{
Number of IOs in progress times the number of milliseconds spent doing IO since
last update of the field - indicator of backlog that may be accumulating
}
\item \declareAttributeProvisional{PMIX_DISK_SAMPLE_TIME}{"pmix.disk.samptime"}{time_t}{
    Time when sample was taken
}
\end{itemize}

\subsubsection{Network resource usage}

\declareAttributeProvisional{PMIX_NETWORK_ID}{"pmix.net.id"}{char*}{
String identifier of a network interface
}

\declareAttributeProvisional{PMIX_NETWORK_RESOURCE_USAGE}{"pmix.net.res"}{pmix_data_array_t*}{
An array of \refstruct{pmix_info_t} describing the resource usage of the specified network, with
the first element containing the string name of the interface (marked by the \refattr{PMIX_NETWORK_ID} key)
whose usage is reported in the array. The list of included information may vary across
implementations and \acp{OS}, depending upon availability and access restrictions, and the
provided list of requested values. Except for
the network ID as the first element, ordering of information in the array is arbitrary.
}

Optional information that may be included (see \href{https://www.kernel.org/doc/html/latest/networking/statistics.html}{NETSTATS} for a detailed description of the following fields):
\begin{itemize}
\item \refattr{PMIX_NETWORK_ID}
\item \declareAttributeProvisional{PMIX_NET_RECVD_BYTES}{"pmix.net.rcb"}{uint64_t}{
Number of bytes received
}
\item \declareAttributeProvisional{PMIX_NET_RECVD_PCKTS}{"pmix.net.rcp"}{uint64_t}{
Number of packets received
}
\item \declareAttributeProvisional{PMIX_NET_RECVD_ERRS}{"pmix.net.rcerr"}{uint64_t}{
Number of receive errors
}
\item \declareAttributeProvisional{PMIX_NET_SENT_BYTES}{"pmix.net.sntb"}{uint64_t}{
Number of bytes sent
}
\item \declareAttributeProvisional{PMIX_NET_SENT_PCKTS}{"pmix.net.sntp"}{uint64_t}{
Number of packets sent
}
\item \declareAttributeProvisional{PMIX_NET_SENT_ERRS}{"pmix.net.snterr"}{uint64_t}{
Number of send errors
}
\item \declareAttributeProvisional{PMIX_NET_SAMPLE_TIME}{"pmix.net.samptime"}{time_t}{
    Time when sample was taken
}
\end{itemize}


\subsubsection{Node resource usage}

\declareAttributeProvisional{PMIX_NODE_RESOURCE_USAGE}{"pmix.node.res"}{pmix_data_array_t*}{
An array of \refstruct{pmix_info_t} describing the overall resource usage on the specified node,
with the first element containing
the ID of the node (marked by the \refattr{PMIX_HOSTNAME} or \refattr{PMIX_NODEID} key) whose usage
is reported in the array. The list of included information may vary across
implementations and \acp{OS}, depending upon availability and access restrictions, and the
provided list of requested values. Except for
the node ID as the first element, ordering of information in the array is arbitrary.

Optional information that may be included (see \href{https://www.kernel.org/doc/html/latest/filesystems/proc.html\#kernel-data}{KERNEL} and \href{https://www.kernel.org/doc/html/latest/filesystems/proc.html\#meminfo}{MEMINFO} for a detailed description of the following fields):
\begin{itemize}
    \item \refattr{PMIX_HOSTNAME}
    \item \refattr{PMIX_NODEID}
    \item \declareAttributeProvisional{PMIX_NODE_LOAD_AVG}{"pmix.node.la"}{float}{
    Load average of last minute
    }
    \item \declareAttributeProvisional{PMIX_NODE_LOAD_AVG5}{"pmix.node.la5"}{float}{
    Load average of last five minutes
    }
    \item \declareAttributeProvisional{PMIX_NODE_LOAD_AVG15}{"pmix.node.la15"}{float}{
    Load average of last fifteen minutes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_TOTAL}{"pmix.node.mtot"}{float}{
    Total usable RAM (i.e., physical RAM minus reserved bits and kernel binary code). In MBytes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_FREE}{"pmix.node.mfree"}{float}{
    Total free RAM. In MBytes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_BUFFERS}{"pmix.node.mbuf"}{float}{
    Temporary storage for raw disk blocks. In MBytes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_CACHED}{"pmix.node.mcache"}{float}{
    In-memory cache for files read from the disk (the pagecache) as well as tmpfs and shmem. In MBytes.
    Doesn't include \refattr{PMIX_NODE_MEM_SWAP_CACHED}.
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_SWAP_CACHED}{"pmix.node.mswpc"}{float}{
    Memory that once was swapped out, is swapped back in but still also is in the swapfile. In MBytes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_SWAP_TOTAL}{"pmix.node.mswpt"}{float}{
    Total amount of swap space available. In MBytes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_SWAP_FREE}{"pmix.node.mswpfree"}{float}{
    Memory which has been evicted from RAM, and is temporarily on the disk. In MBytes
    }
    \item \declareAttributeProvisional{PMIX_NODE_MEM_MAPPED}{"pmix.node.mmap"}{float}{
    files which have been mmapped, such as libraries. Note that some kernel configurations might consider all pages part of a larger allocation (e.g., THP) as mapped, as soon as a single page is mapped. In MBytes
    }
    \item \refattr{PMIX_DISK_RESOURCE_USAGE} One for each disk attached to the node, if requested.
    \item \refattr{PMIX_NETWORK_RESOURCE_USAGE} One for each network interface on the node, if requested.
    \item \declareAttributeProvisional{PMIX_NODE_SAMPLE_TIME}{"pmix.node.samptime"}{time_t}{
        Time when sample was taken
    }
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logging}
\label{chap:api_job_mgmt:logging}

The logging interface supports posting information by applications and SMS elements to persistent storage. This function is \textit{not} intended for output of computational results, but rather for reporting status and saving state information such as inserting computation progress reports into the application's \ac{SMS} job log or error reports to the local syslog.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Log}}
\declareapi{PMIx_Log}

%%%%
\summary

Log data to a data service.

%%%%
\format

\copySignature{PMIx_Log}{3.0}{
pmix_status_t \\
PMIx_Log(const pmix_info_t data[], size_t ndata, \\
\hspace*{9\sigspace}const pmix_info_t directives[], size_t ndirs);
}

\begin{arglist}
\argin{data}{Array of info structures (array of handles)}
\argin{ndata}{Number of elements in the \refarg{data} array (\code{size_t})}
\argin{directives}{Array of info structures (array of handles)}
\argin{ndirs}{Number of elements in the \refarg{directives} array (\code{size_t})}
\end{arglist}

\returnsimple

\reqattrstart
If the \ac{PMIx} library does not itself perform this operation, then it is required to pass any attributes provided by the client to the host environment for processing. In addition, it must include the following attributes in the passed \refarg{directives} array:

\pasteAttributeItem{PMIX_USERID}
\pasteAttributeItem{PMIX_GRPID}

Host environments or \ac{PMIx} libraries that implement support for this operation are required to support the following attributes when provided as part of the \refarg{data} array:

\pasteAttributeItem{PMIX_LOG_STDERR}
\pasteAttributeItem{PMIX_LOG_STDOUT}
\pasteAttributeItem{PMIX_LOG_SYSLOG}

Similarly, the following attributes must be supported when provided as part of the \refarg{directives} array:

\pasteAttributeItem{PMIX_LOG_SYSLOG_PRI}
\pasteAttributeItem{PMIX_LOG_ONCE}

\reqattrend

\optattrstart
The following attributes are optional for host environments or \ac{PMIx} libraries that support this operation when provided as part of the \refarg{data} array:

\pasteAttributeItem{PMIX_LOG_EMAIL}
\pasteAttributeItem{PMIX_LOG_JOB_RECORD}
\pasteAttributeItem{PMIX_LOG_GLOBAL_DATASTORE}
\pasteAttributeItem{PMIX_LOG_LOCAL_SYSLOG}
\pasteAttributeItem{PMIX_LOG_GLOBAL_SYSLOG}

Similarly, the following attributes are optional when provided as part of the \refarg{directives} array:

\pasteAttributeItem{PMIX_LOG_SOURCE}
\pasteAttributeItem{PMIX_LOG_TIMESTAMP}
\pasteAttributeItem{PMIX_LOG_GENERATE_TIMESTAMP}
\pasteAttributeItem{PMIX_LOG_TAG_OUTPUT}
\pasteAttributeItem{PMIX_LOG_TIMESTAMP_OUTPUT}
\pasteAttributeItem{PMIX_LOG_XML_OUTPUT}


\optattrend

%%%%
\descr

Log data subject to the services offered by the host environment. The \refarg{data} array is used to specify the information that is to be logged, while the \refarg{directives} array is used to control formatting and other output options. For example, a user can:

\begin{itemize}
\item log a message to \code{stderr} by including \refattr{PMIX_LOG_STDERR} in the \refarg{data} array, with the message itself provided as a string value in that \refstruct{pmix_info_t} element. They can also have that message time-stamped by including the \refattr{PMIX_LOG_TIMESTAMP} attribute in the \refarg{directives} array.
\item send an email to one or more recipients by including \refattr{PMIX_LOG_EMAIL} in the \refarg{data} array, with the \refstruct{pmix_data_array_t} value containing the message, recipient, and any required server information. Note that any \refarg{directives} (e.g., \refattr{PMIX_LOG_GENERATE_TIMESTAMP}) will be applied to the email request.
\item log a message to the syslog on the system console by including \refattr{PMIX_LOG_GLOBAL_SYSLOG} in the \refarg{data} array, with the message itself provided as a string value in that \refstruct{pmix_info_t} element. The syslog priority could be set with \refattr{PMIX_LOG_SYSLOG_PRI} in the \refarg{directives} array.
\end{itemize}

Note that it is possible to log multiple messages to different channels using a single call to \refapi{PMIx_Log}. For instance, the above examples could be combined into a single call to \refapi{PMIx_Log}. In this case, only directives that are applicable to a channel will be used in outputting to that channel. For this example, a directive such as \refattr{PMIX_LOG_TIMESTAMP} would cause all three messages to be time-stamped, but a \refattr{PMIX_LOG_SYSLOG_PRI} directive would only be applied to the syslog channel.

Multiple instances of the same attribute can be included in the \refarg{data} array - e.g., to send different emails to various recipients.

\adviceuserstart
It is strongly recommended that the \refapi{PMIx_Log} API not be used by applications for streaming data as it is not a ``performant'' transport and can perturb the application since it involves the local \ac{PMIx} server and host \ac{SMS} daemon. Note that a return of \refconst{PMIX_SUCCESS} only denotes that the data was successfully handed to the appropriate system call (for local channels) or the host environment and does not indicate receipt at the final destination.
\adviceuserend

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\code{PMIx_Log_nb}}
\declareapi{PMIx_Log_nb}

%%%%
\summary

Log data to a data service.

%%%%
\format

\copySignature{PMIx_Log_nb}{2.0}{
pmix_status_t \\
PMIx_Log_nb(const pmix_info_t data[], size_t ndata, \\
\hspace*{12\sigspace}const pmix_info_t directives[], size_t ndirs, \\
\hspace*{12\sigspace}pmix_op_cbfunc_t cbfunc, void *cbdata);
}

\begin{arglist}
\argin{data}{Array of info structures (array of handles)}
\argin{ndata}{Number of elements in the \refarg{data} array (\code{size_t})}
\argin{directives}{Array of info structures (array of handles)}
\argin{ndirs}{Number of elements in the \refarg{directives} array (\code{size_t})}
\argin{cbfunc}{Callback function \refapi{pmix_op_cbfunc_t} (function reference)}
\argin{cbdata}{Data to be passed to the callback function (memory reference)}
\end{arglist}

Return codes are one of the following:

\returnsimplenb

\returnstart
\begin{constantdesc}
\item \refconst{PMIX_OPERATION_SUCCEEDED}, indicating that the request was immediately processed and returned \textit{success} - the \refarg{cbfunc} will \textit{not} be called
\item \refconst{PMIX_ERR_BAD_PARAM} The logging request contains at least one incorrect entry that prevents it from being processed. The callback function will not be called.
\end{constantdesc}
\returnend

\reqattrstart
If the \ac{PMIx} library does not itself perform this operation, then it is required to pass any attributes provided by the client to the host environment for processing. In addition, it must include the following attributes in the passed \refarg{directives} array:

\pasteAttributeItem{PMIX_USERID}
\pasteAttributeItem{PMIX_GRPID}

Host environments or \ac{PMIx} libraries that implement support for this operation are required to support the following attributes when provided as part of the \refarg{data} array:

\pasteAttributeItem{PMIX_LOG_STDERR}
\pasteAttributeItem{PMIX_LOG_STDOUT}
\pasteAttributeItem{PMIX_LOG_SYSLOG}

Similarly, the following attributes must be supported when provided as part of the \refarg{directives} array:

\pasteAttributeItem{PMIX_LOG_SYSLOG_PRI}
\pasteAttributeItem{PMIX_LOG_ONCE}

\reqattrend

\optattrstart
The following attributes are optional for host environments or \ac{PMIx} libraries that support this operation when provided as part of the \refarg{data} array:

\pasteAttributeItem{PMIX_LOG_EMAIL}
\pasteAttributeItem{PMIX_LOG_JOB_RECORD}
\pasteAttributeItem{PMIX_LOG_GLOBAL_DATASTORE}
\pasteAttributeItem{PMIX_LOG_LOCAL_SYSLOG}
\pasteAttributeItem{PMIX_LOG_GLOBAL_SYSLOG}

Similarly, the following attributes are optional when provided as part of the \refarg{directives} array:

\pasteAttributeItem{PMIX_LOG_SOURCE}
\pasteAttributeItem{PMIX_LOG_TIMESTAMP}
\pasteAttributeItem{PMIX_LOG_GENERATE_TIMESTAMP}
\pasteAttributeItem{PMIX_LOG_TAG_OUTPUT}
\pasteAttributeItem{PMIX_LOG_TIMESTAMP_OUTPUT}
\pasteAttributeItem{PMIX_LOG_XML_OUTPUT}


\optattrend

%%%%
\descr

Log data subject to the services offered by the host environment. See the description in \refapi{PMIx_Log} for details on use of the \refarg{data} and \refarg{directives} arrays.

\adviceuserstart
It is strongly recommended that the \refapi{PMIx_Log_nb} API not be used by applications for streaming data as it is not a ``performant'' transport and can perturb the application since it involves the local \ac{PMIx} server and host \ac{SMS} daemon. Note that a return of \refconst{PMIX_SUCCESS} only denotes that the data was successfully handed to the appropriate system call (for local channels) or the host environment and does not indicate receipt at the final destination.
\adviceuserend


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Log attributes}
\label{api:struct:attributes:log}

Attributes used to describe \refapi{PMIx_Log} behavior - these are values passed to the \refapi{PMIx_Log} \ac{API} and therefore are not accessed using the \refapi{PMIx_Get} \ac{API}.

%
\declareAttribute{PMIX_LOG_SOURCE}{"pmix.log.source"}{pmix_proc_t*}{
ID of source of the log request.
}
%
\declareAttribute{PMIX_LOG_STDERR}{"pmix.log.stderr"}{char*}{
Log string to \code{stderr}.
}
%
\declareAttribute{PMIX_LOG_STDOUT}{"pmix.log.stdout"}{char*}{
Log string to \code{stdout}.
}
%
\declareAttribute{PMIX_LOG_SYSLOG}{"pmix.log.syslog"}{char*}{
Log data to syslog.
Defaults to \code{ERROR} priority.  Will log to global syslog if available, otherwise to local syslog.
}
%
\declareAttribute{PMIX_LOG_LOCAL_SYSLOG}{"pmix.log.lsys"}{char*}{
Log data to local syslog.
Defaults to \code{ERROR} priority.
}
%
\declareAttribute{PMIX_LOG_GLOBAL_SYSLOG}{"pmix.log.gsys"}{char*}{
Forward data to system ``gateway'' and log msg to that syslog
Defaults to \code{ERROR} priority.
}
%
\declareAttribute{PMIX_LOG_SYSLOG_PRI}{"pmix.log.syspri"}{int}{
Syslog priority level.
}
%
\declareAttribute{PMIX_LOG_TIMESTAMP}{"pmix.log.tstmp"}{time_t}{
Timestamp for log report.
}
%
\declareAttribute{PMIX_LOG_GENERATE_TIMESTAMP}{"pmix.log.gtstmp"}{bool}{
Generate timestamp for log.
}
%
\declareAttribute{PMIX_LOG_TAG_OUTPUT}{"pmix.log.tag"}{bool}{
Label the output stream with the channel name (e.g., ``stdout'').
}
%
\declareAttribute{PMIX_LOG_TIMESTAMP_OUTPUT}{"pmix.log.tsout"}{bool}{
Print timestamp in output string.
}
%
\declareAttribute{PMIX_LOG_XML_OUTPUT}{"pmix.log.xml"}{bool}{
Print the output stream in \ac{XML} format.
}
%
\declareAttribute{PMIX_LOG_ONCE}{"pmix.log.once"}{bool}{
Only log this once with whichever channel can first support it, taking the channels in priority order.
}
%
\declareAttribute{PMIX_LOG_EMAIL}{"pmix.log.email"}{pmix_data_array_t}{
Log via email based on \refstruct{pmix_info_t} containing directives. The array must contain at least one of
the \refattr{PMIX_LOG_BLOB} or \refattr{PMIX_LOG_MSG} attributes containing the body of the
message. In addition, it must contain at least the \refattr{PMIX_LOG_EMAIL_ADDR} and \refattr{PMIX_LOG_EMAIL_SUBJECT}
attributes identifying the intended recipients and the subject for the message. The array can optionally include
the server information (\refattr{PMIX_LOG_EMAIL_SERVER} and \refattr{PMIX_LOG_EMAIL_SRVR_PORT}) if required by the
local system, and a return email address for the sender (\refattr{PMIX_LOG_EMAIL_SENDER_ADDR}. No specific ordering
of these directives is required.
}
%
\declareAttribute{PMIX_LOG_EMAIL_ADDR}{"pmix.log.emaddr"}{char*}{
Comma-delimited list of email addresses that are to receive the message.
}
%
\declareAttribute{PMIX_LOG_EMAIL_SENDER_ADDR}{"pmix.log.emfaddr"}{char*}{
Return email address of sender.
}
%
\declareAttribute{PMIX_LOG_EMAIL_SUBJECT}{"pmix.log.emsub"}{char*}{
Subject line for email.
}
%
\declareAttribute{PMIX_LOG_MSG}{"pmix.log.msg"}{char*}{
Message to be included in a log operation.
}
%
\declareAttributeProvisional{PMIX_LOG_BLOB}{"pmix.log.blob"}{pmix_byte_object_t}{
Message blob (e.g., PDF attachment) to be included in a log operation.
}
%
\declareAttribute{PMIX_LOG_EMAIL_SERVER}{"pmix.log.esrvr"}{char*}{
Hostname (or \ac{IP} address) of SMTP server.
}
%
\declareAttribute{PMIX_LOG_EMAIL_SRVR_PORT}{"pmix.log.esrvrprt"}{int32_t}{
Port the email server is listening to.
}
%
\declareAttributeProvisional{PMIX_LOG_GLOBAL_DATASTORE}{"pmix.log.gstore"}{pmix_data_array_t}{
Store the log data in a global data store (e.g., database). Directs the host environment to
store the provided message in a data store available
to the host. The associated array must contain at least one of
the \refattr{PMIX_LOG_BLOB} or \refattr{PMIX_LOG_MSG} attributes containing the data to be
stored.
}
%
\declareAttributeProvisional{PMIX_LOG_JOB_RECORD}{"pmix.log.jrec"}{char*}{
Log the provided message to the host environment's job record. An error must be returned if the host
does not support this service.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
